
# GoCache

GoCache — это высокопроизводительный, потокобезопасный in-memory key-value кэш, написанный на Go. Проект создан как pet-проект для демонстрации глубокого понимания Go, конкурентности, сетевого программирования и архитектуры программного обеспечения.

## Особенности

*   **Высокая производительность:** Использование шардирования для минимизации конкуренции за блокировки на многоядерных системах.
*   **Потокобезопасность:** Все операции полностью безопасны для использования в конкурентной среде.
*   **Политика вытеснения LRU:** Автоматическое удаление давно неиспользуемых элементов при достижении лимита памяти.
*   **Поддержка TTL:** Возможность устанавливать время жизни для ключей с автоматической очисткой.
*   **Персистентность:** Сохранение состояния кэша на диск (снапшоты) и восстановление после перезапуска.
*   **Сетевой доступ:** Простой текстовый TCP-протокол, совместимый с `telnet` / `netcat`.
*   **Graceful Shutdown:** Корректное завершение работы с сохранением данных.

## План разработки (Roadmap)

### Этап 1: Ядро и Сеть
- [x] **V1:** Реализовано базовое потокобезопасное Key-Value ядро на `sync.RWMutex`.
- [x] **V2:** Реализована поддержка TTL (Time-To-Live) для ключей с фоновой очисткой.
- [x] **V3:** Реализован сетевой TCP-сервер и Graceful Shutdown для корректной остановки.

### Этап 2: Надежность и Эффективность
- [x] **V4:** Реализована персистентность — сохранение и загрузка снапшотов кэша с диска (`dump.gob`).
- [x] **V5:** Реализована политика вытеснения LRU (Least Recently Used) с помощью `map` и `container/list`.
- [ ] **V6:** **Рефакторинг ядра на шардированную архитектуру.**
    - [ ] Разделение единого хранилища на N независимых сегментов (шардов).
    - [ ] Реализация роутинга ключей по шардам на основе хэш-функции.
    - [ ] У каждого шарда свой независимый мьютекс для снижения конкуренции за блокировку.

### Этап 3: Восстановление функциональности на новой архитектуре
- [ ] **V7:** **Интеграция LRU и TTL в шарды.**
    - [ ] Реализация логики LRU и TTL на уровне каждого отдельного шарда.
    - [ ] Реализация механизма `Stop` для корректной остановки фоновых процессов в шардах.
- [ ] **V8:** **Реализация персистентности для шардированного кэша.**
    - [ ] Реализация `SaveToFile`, который будет агрегировать данные со всех шардов.
    - [ ] Реализация `LoadFromFile`, который будет распределять данные по шардам.

### Этап 4: Управление и Эксплуатация
- [ ] **V9:** **Реализация атомарных операций и дополнительных команд.**
    - [ ] Добавление команд `INCR`/`DECR` для атомарного увеличения/уменьшения числовых значений.
- [ ] **V10:** **Улучшенный CLI и управление конфигурацией.**
    - [ ] Запуск сервера с параметрами командной строки (`--port`, `--shards`, `--max-size` и т.д.).
    - [ ] Реализация команд `CONFIG GET` и `CONFIG SET` для просмотра и изменения параметров "на лету".
    - [ ] Реализация команды `INFO` для получения статистики о работе сервера (количество ключей, аптайм, хитрейт и т.д.).

## Как запустить

### Запуск сервера
```shell
# Сборка и запуск сервера
go run ./cmd/gocache-server/

### Взаимодействие с сервером
````
Откройте новый терминал и подключитесь с помощью `netcat` или `telnet`:
```shell
  nc localhost 6379

  
```
Поддерживаемые команды
```
# Установить значение "myvalue" для ключа "mykey" с TTL 60 секунд
SET mykey myvalue 60
> OK

# Получить значение по ключу "mykey"
GET mykey
> myvalue

# Получить значение несуществующего ключа
GET non_existent_key
> (nil)

# Удалить ключ "mykey"
DELETE mykey
> 1

# Очистить экран терминала
CLEAR

# Завершить сессию
EXIT
```
  

Тестирование
``` 
# Запустить все тесты
make test

# Запустить тесты с детектором гонок
make test-race
```
